<!DOCTYPE html>
<html lang="en">

<head>
  <title>wordle stats</title>
  <meta charset="UTF-8">
  <meta name="description" content="gather some statistics from past wordle answers">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex,nofollow">

  <script src="https://code.jquery.com/jquery-3.7.1.slim.min.js"></script>
  <script>
    $(_ => {
      $(document.body)
        .on('change', '>.show-hide>.toggle-dups', _ => $(document.body).toggleClass('only-dups'))
        .on('keyup', '>.search>input', e => {
          if (!e.currentTarget.value) {
            $('body>.words').removeClass('matching')
            return
          }

          $('body>.words')
            .addClass('matching')
            .find('>li.matched')
            .removeClass('matched')

          let srch = new RegExp(e.currentTarget.value, 'i')

          $('body>.words>li')
            .filter((_, li) => srch.test(li.attributes.id.value))
            .addClass('matched')
        })
        .on('click', '>.search>.clear', _ => $('body>.search>input').val('').trigger('keyup'))

      let url = 'wordle-source' //'https://www.rockpapershotgun.com/wordle-past-answers'
      fetch(url)
        .then(async resp => {
          if (resp.status !== 200) throw JSON.stringify({
            status: resp.status,
            message: await resp.text(),
          })

          return await resp.text()
        })
        .then(text => $(text).find('ul.inline>li'))
        // // XXX: begin future proofing for repeated words, might have to find a 
        // //   new source with dates for this to work; save each date as attr/data
        // //   and concatenate dates when removing nodes
        // .then(items => {
        //   let length = items.length

        //   return items
        //     .slice(0, length - 1)
        //     .filter((i, v) => {
        //       let next = items.get(i + 1)
        //       if (v.innerText === next.innerText) {
        //         next.setAttribute('repeated', v.getAttribute('repeated') + 1)
        //         return false
        //       }
        //       return true
        //     })
        //     .add(items[length - 1])
        // })
        .then(items => {
          $('body>.results>.total').text(items.length)

          return items.each((_, item) => {
            let chars = {}
            item.setAttribute('id', item.innerText)
            item.innerText.split('').map(letter => chars[letter] = (chars[letter] ?? 0) + 1)

            chars = Object.fromEntries(Object.entries(chars).filter(dup => dup[1] > 1))
            if (Object.entries(chars).length > 0) {
              $(item).addClass('dup').append($('<span>').text(JSON.stringify(chars)))
            }

            // // XXX: future proofing for repeated words
            // let repeated = item.getAttribute('repeated')
            // if (repeated) {
            //   $(item).append($('<span class=repeated>').text(`x${repeated}`))
            // }
          })
        })
        .then(words => $('body>.words').append(words).find('>.dup'))
        .then(dups => $('body>.results>.dups').text(dups.length))
        .catch(ex => $(document.body)
          .addClass('failure')
          .find('>.exception')
          .text(`caught exception ${ex} processing url ${url} stack ${ex.stack}`))
    })
  </script>
  <style>
    * {
      color: white;
      font-family: system-ui;
    }

    html {
      background-color: #0e0c23;
    }

    input {
      appearance: none;
      background-color: #fff2;
      border: 0;
      border-radius: .33em;
      color: white;
      display: inline-block;
      font-size: large;
      outline: none;
      overflow: clip;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    body {

      &.failure>:not(.exception),
      &>.exception {
        display: none;
      }

      &.failure>.exception {
        color: #fd8585;
        display: initial;
        font-weight: bolder;
      }

      &>.show-hide {
        &::before {
          content: 'showing';
        }

        &::after {
          color: cyan;
          content: 'all';
          text-decoration: underline;
        }

        cursor: pointer;
        display: block;

        &>input {
          display: none;
        }
      }

      &.only-dups {
        &>.show-hide::after {
          content: 'only dups';
        }

        &>.words>li:not(.dup) {
          display: none;
        }
      }

      &>.search {
        line-height: 2em;

        &>* {
          display: inline;
        }

        &>.clear {
          color: red;
          cursor: pointer;
          margin-left: .33em;
        }
      }

      &>ul.words {
        &>li span {
          padding-left: .33em;

          /* XXX: future proofing for repeated words */
          /* 
          &.repeated {
            font-style: italic;
          } 
           */
        }

        &.matching>li:not(.matched) {
          display: none;
        }
      }
    }
  </style>
</head>

<body>
  <div class="title">
    the source list is proxied from <a href='https://www.rockpapershotgun.com/wordle-past-answers'>rockpapershotgun</a>
  </div>
  <div class="results">
    <span class="total">&nbsp;</span> total words
    <br>
    <span class="dups">&nbsp;</span> having less than 5 unique letters
  </div>
  <label class="show-hide">
    <input class="toggle-dups" type="checkbox" checked="checked">
  </label>
  <label class="search">
    <input type="text" autocapitalize="off" placeholder="(filter)">
    <div class="button clear" title="clear">&#10008;</div>
  </label>
  <ul class="words"></ul>
  <div class="exception">&nbsp;</div>
</body>

</html>